
import * as XLSX from 'xlsx';
import { Document, Packer, Paragraph, TextRun, HeadingLevel, Table, TableRow, TableCell, WidthType } from 'docx';
import pptxgen from "pptxgenjs";

export const exportToExcel = (headers: string[], rows: any[][], filename: string) => {
    const worksheet = XLSX.utils.aoa_to_sheet([headers, ...rows]);
    const workbook = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(workbook, worksheet, "Data");
    XLSX.writeFile(workbook, `${filename}.xlsx`);
};

export const exportToWord = async (headers: string[], rows: any[][], filename: string) => {
    // Check if it's semantic/structured data from our new AI prompts
    const isSemantic = headers.includes('role') && headers.includes('content');

    let children: any[] = [
        new Paragraph({
            text: filename.replace(/_/g, ' '),
            heading: HeadingLevel.HEADING_1,
            spacing: { after: 400 },
        }),
        new Paragraph({
            text: `Generated by GridFlow AI - ${new Date().toLocaleDateString()}`,
            spacing: { after: 400 },
        }),
    ];

    if (isSemantic) {
        const roleIdx = headers.indexOf('role');
        const contentIdx = headers.indexOf('content');

        rows.forEach(row => {
            const role = String(row[roleIdx]).toLowerCase();
            const content = String(row[contentIdx]);

            if (role.includes('title')) {
                children.push(new Paragraph({ text: content, heading: HeadingLevel.HEADING_2, spacing: { before: 400, after: 200 } }));
            } else if (role.includes('header') || role.includes('heading')) {
                children.push(new Paragraph({ text: content, heading: HeadingLevel.HEADING_3, spacing: { before: 300, after: 150 } }));
            } else if (role.includes('bullet') || role.includes('list')) {
                children.push(new Paragraph({ text: content, bullet: { level: 0 }, spacing: { after: 120 } }));
            } else {
                children.push(new Paragraph({ text: content, spacing: { after: 200 } }));
            }
        });
    } else {
        // Fallback to table layout for generic data
        children.push(new Table({
            width: { size: 100, type: WidthType.PERCENTAGE },
            rows: [
                new TableRow({
                    children: headers.map(header => new TableCell({
                        children: [new Paragraph({ text: header, style: 'Bold' })],
                        shading: { fill: "f3f4f6" }
                    })),
                }),
                ...rows.map(row => new TableRow({
                    children: row.map(cell => new TableCell({
                        children: [new Paragraph({ text: String(cell) })],
                    })),
                })),
            ],
        }));
    }

    const doc = new Document({ sections: [{ children }] });
    const blob = await Packer.toBlob(doc);
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${filename}.docx`;
    a.click();
    window.URL.revokeObjectURL(url);
};

export const exportToPPT = async (headers: string[], rows: any[][], filename: string) => {
    const pres = new pptxgen();
    const isSlideData = headers.includes('slide_title') && headers.includes('bullet_points');

    // Title Slide
    let slide = pres.addSlide();
    slide.addText("GridFlow AI Extraction Report", { x: 1, y: 1.5, w: 8, h: 1, fontSize: 36, bold: true, align: 'center', color: '4B44E5' });
    slide.addText(filename.replace(/_/g, ' '), { x: 1, y: 2.5, w: 8, h: 1, fontSize: 24, align: 'center', color: '64748B' });
    slide.addText(new Date().toLocaleDateString(), { x: 1, y: 4, w: 8, fontSize: 14, align: 'center', color: '94A3B8' });

    if (isSlideData) {
        const titleIdx = headers.indexOf('slide_title');
        const bulletIdx = headers.indexOf('bullet_points');

        rows.forEach(row => {
            const title = String(row[titleIdx]);
            let bullets = row[bulletIdx];

            // Handle cases where AI returns a string representation of an array or JSON
            if (typeof bullets === 'string' && bullets.startsWith('[')) {
                try { bullets = JSON.parse(bullets); } catch (e) { }
            }
            const bulletList = Array.isArray(bullets) ? bullets : [String(bullets)];

            let dataSlide = pres.addSlide();
            dataSlide.addText(title, { x: 0.5, y: 0.5, w: 9, fontSize: 28, bold: true, color: '1E293B' });
            dataSlide.addText(
                bulletList.map(b => ({ text: b, options: { bullet: true, indentLevel: 0, fontSize: 18, color: '475569' } })),
                { x: 0.5, y: 1.5, w: 9, h: 4 }
            );
        });
    } else if (rows.length > 0) {
        // Fallback to table layout
        const chunkSize = 8;
        for (let i = 0; i < rows.length; i += chunkSize) {
            const chunk = rows.slice(i, i + chunkSize);
            let dataSlide = pres.addSlide();
            dataSlide.addText(`Data Table (Part ${Math.floor(i / chunkSize) + 1})`, { x: 0.5, y: 0.5, fontSize: 18, bold: true });
            dataSlide.addTable([headers, ...chunk], { x: 0.5, y: 1.2, w: 9, fontSize: 10, border: { type: 'solid', color: 'E2E8F0' } });
        }
    }

    pres.writeFile({ fileName: `${filename}.pptx` });
};

export const exportToCSV = (headers: string[], rows: any[][], filename: string) => {
    const worksheet = XLSX.utils.aoa_to_sheet([headers, ...rows]);
    const csvContent = XLSX.utils.sheet_to_csv(worksheet);
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${filename}.csv`;
    a.click();
    window.URL.revokeObjectURL(url);
};
